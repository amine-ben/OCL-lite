/*
 * generated by Xtext 2.10.0
 */
package fr.inria.diverse.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.oCLlite.AddOpCallExp;
import fr.inria.diverse.oCLlite.BagExp;
import fr.inria.diverse.oCLlite.BagType;
import fr.inria.diverse.oCLlite.BoolOpCallExp;
import fr.inria.diverse.oCLlite.BooleanLiteralExp;
import fr.inria.diverse.oCLlite.BooleanType;
import fr.inria.diverse.oCLlite.CollectionOpCallExp;
import fr.inria.diverse.oCLlite.ComOpCallExp;
import fr.inria.diverse.oCLlite.ElseIfThenExp;
import fr.inria.diverse.oCLlite.EnvType;
import fr.inria.diverse.oCLlite.EqOpCallExp;
import fr.inria.diverse.oCLlite.IfExp;
import fr.inria.diverse.oCLlite.Import;
import fr.inria.diverse.oCLlite.IntegerType;
import fr.inria.diverse.oCLlite.InvalidLiteralExp;
import fr.inria.diverse.oCLlite.IterateExp;
import fr.inria.diverse.oCLlite.Iterator;
import fr.inria.diverse.oCLlite.IteratorExp;
import fr.inria.diverse.oCLlite.LambdaExp;
import fr.inria.diverse.oCLlite.LambdaType;
import fr.inria.diverse.oCLlite.LocalVariable;
import fr.inria.diverse.oCLlite.MapElement;
import fr.inria.diverse.oCLlite.MapExp;
import fr.inria.diverse.oCLlite.MapType;
import fr.inria.diverse.oCLlite.Module;
import fr.inria.diverse.oCLlite.MulOpCallExp;
import fr.inria.diverse.oCLlite.NavigationExp;
import fr.inria.diverse.oCLlite.NavigationOrAttributeCall;
import fr.inria.diverse.oCLlite.NestedExp;
import fr.inria.diverse.oCLlite.NullLiteralExp;
import fr.inria.diverse.oCLlite.NumberLiteralExp;
import fr.inria.diverse.oCLlite.OCLlitePackage;
import fr.inria.diverse.oCLlite.OclLAnyType;
import fr.inria.diverse.oCLlite.OclLExpression;
import fr.inria.diverse.oCLlite.OclLModel;
import fr.inria.diverse.oCLlite.OclLModelElementExp;
import fr.inria.diverse.oCLlite.OperationCall;
import fr.inria.diverse.oCLlite.OrderedSetExp;
import fr.inria.diverse.oCLlite.OrderedSetType;
import fr.inria.diverse.oCLlite.Query;
import fr.inria.diverse.oCLlite.RealType;
import fr.inria.diverse.oCLlite.SelfExp;
import fr.inria.diverse.oCLlite.SequenceExp;
import fr.inria.diverse.oCLlite.SequenceType;
import fr.inria.diverse.oCLlite.SetExp;
import fr.inria.diverse.oCLlite.SetType;
import fr.inria.diverse.oCLlite.StringLiteralExp;
import fr.inria.diverse.oCLlite.StringType;
import fr.inria.diverse.oCLlite.TupleExp;
import fr.inria.diverse.oCLlite.TuplePart;
import fr.inria.diverse.oCLlite.URI_;
import fr.inria.diverse.oCLlite.UnlimitedNaturalLiteralExp;
import fr.inria.diverse.services.OCLliteGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OCLliteSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OCLliteGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OCLlitePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OCLlitePackage.ADD_OP_CALL_EXP:
				sequence_AdditionOpExp(context, (AddOpCallExp) semanticObject); 
				return; 
			case OCLlitePackage.BAG_EXP:
				sequence_BagExp(context, (BagExp) semanticObject); 
				return; 
			case OCLlitePackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case OCLlitePackage.BOOL_OP_CALL_EXP:
				if (rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclLExpressionRule()
						|| rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_ImpliesOpExp_OrOpExp_XorOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_OrOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_OrOpExp_XorOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else break;
			case OCLlitePackage.BOOLEAN_LITERAL_EXP:
				sequence_BooleanExp(context, (BooleanLiteralExp) semanticObject); 
				return; 
			case OCLlitePackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case OCLlitePackage.COLLECTION_OP_CALL_EXP:
				sequence_CollectionOpCall(context, (CollectionOpCallExp) semanticObject); 
				return; 
			case OCLlitePackage.COM_OP_CALL_EXP:
				sequence_ComparisonOpExp(context, (ComOpCallExp) semanticObject); 
				return; 
			case OCLlitePackage.ELSE_IF_THEN_EXP:
				sequence_ElseIfThenExp(context, (ElseIfThenExp) semanticObject); 
				return; 
			case OCLlitePackage.ENV_TYPE:
				sequence_EnvType(context, (EnvType) semanticObject); 
				return; 
			case OCLlitePackage.EQ_OP_CALL_EXP:
				sequence_EqOpExp(context, (EqOpCallExp) semanticObject); 
				return; 
			case OCLlitePackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case OCLlitePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case OCLlitePackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case OCLlitePackage.INVALID_LITERAL_EXP:
				sequence_InvalidExp(context, (InvalidLiteralExp) semanticObject); 
				return; 
			case OCLlitePackage.ITERATE_EXP:
				sequence_IterateExp(context, (IterateExp) semanticObject); 
				return; 
			case OCLlitePackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case OCLlitePackage.ITERATOR_EXP:
				sequence_IteratorExp(context, (IteratorExp) semanticObject); 
				return; 
			case OCLlitePackage.LAMBDA_EXP:
				sequence_LambdaExp(context, (LambdaExp) semanticObject); 
				return; 
			case OCLlitePackage.LAMBDA_TYPE:
				sequence_LambdaType(context, (LambdaType) semanticObject); 
				return; 
			case OCLlitePackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case OCLlitePackage.MAP_ELEMENT:
				sequence_MapElement(context, (MapElement) semanticObject); 
				return; 
			case OCLlitePackage.MAP_EXP:
				sequence_MapExp(context, (MapExp) semanticObject); 
				return; 
			case OCLlitePackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case OCLlitePackage.MODULE:
				sequence_Module(context, (Module) semanticObject); 
				return; 
			case OCLlitePackage.MUL_OP_CALL_EXP:
				sequence_MultiOpExp(context, (MulOpCallExp) semanticObject); 
				return; 
			case OCLlitePackage.NAVIGATION_EXP:
				sequence_NavOpExp(context, (NavigationExp) semanticObject); 
				return; 
			case OCLlitePackage.NAVIGATION_OR_ATTRIBUTE_CALL:
				sequence_NavigationOrAttributeCall(context, (NavigationOrAttributeCall) semanticObject); 
				return; 
			case OCLlitePackage.NESTED_EXP:
				sequence_NestedExp(context, (NestedExp) semanticObject); 
				return; 
			case OCLlitePackage.NULL_LITERAL_EXP:
				sequence_NullExp(context, (NullLiteralExp) semanticObject); 
				return; 
			case OCLlitePackage.NUMBER_LITERAL_EXP:
				sequence_NumberExp(context, (NumberLiteralExp) semanticObject); 
				return; 
			case OCLlitePackage.OCL_LANY_TYPE:
				sequence_OclLAnyType(context, (OclLAnyType) semanticObject); 
				return; 
			case OCLlitePackage.OCL_LEXPRESSION:
				if (rule == grammarAccess.getLetExpRule()) {
					sequence_LetExp(context, (OclLExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclLExpressionRule()) {
					sequence_LetExp_OclLModelElementExp_UnaryOpExp(context, (OclLExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getEqOpExpRule()
						|| action == grammarAccess.getEqOpExpAccess().getEqOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getComparisonOpExpRule()
						|| action == grammarAccess.getComparisonOpExpAccess().getComOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAdditionOpExpRule()
						|| action == grammarAccess.getAdditionOpExpAccess().getAddOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getMultiOpExpRule()
						|| action == grammarAccess.getMultiOpExpAccess().getMulOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getNavOpExpRule()
						|| action == grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0()
						|| rule == grammarAccess.getNavigationOpCallExpRule()
						|| rule == grammarAccess.getOclLModelElementExpRule()
						|| rule == grammarAccess.getPrimaryExpRule()) {
					sequence_OclLModelElementExp(context, (OclLExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryOpExpRule()) {
					sequence_UnaryOpExp(context, (OclLExpression) semanticObject); 
					return; 
				}
				else break;
			case OCLlitePackage.OCL_LMODEL:
				sequence_OclLModel(context, (OclLModel) semanticObject); 
				return; 
			case OCLlitePackage.OCL_LMODEL_ELEMENT_EXP:
				sequence_OclLModelElement(context, (OclLModelElementExp) semanticObject); 
				return; 
			case OCLlitePackage.OPERATION_CALL:
				if (rule == grammarAccess.getAllInstancesOpCallRule()) {
					sequence_AllInstancesOpCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclLExpressionRule()
						|| rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getEqOpExpRule()
						|| action == grammarAccess.getEqOpExpAccess().getEqOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getComparisonOpExpRule()
						|| action == grammarAccess.getComparisonOpExpAccess().getComOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAdditionOpExpRule()
						|| action == grammarAccess.getAdditionOpExpAccess().getAddOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getMultiOpExpRule()
						|| action == grammarAccess.getMultiOpExpAccess().getMulOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getNavOpExpRule()
						|| action == grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0()
						|| rule == grammarAccess.getNavigationOpCallExpRule()
						|| rule == grammarAccess.getOperationCallRule()) {
					sequence_OperationCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else break;
			case OCLlitePackage.ORDERED_SET_EXP:
				sequence_OrderedSetExp(context, (OrderedSetExp) semanticObject); 
				return; 
			case OCLlitePackage.ORDERED_SET_TYPE:
				sequence_OrderedSetType(context, (OrderedSetType) semanticObject); 
				return; 
			case OCLlitePackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case OCLlitePackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case OCLlitePackage.SELF_EXP:
				sequence_SeflExp(context, (SelfExp) semanticObject); 
				return; 
			case OCLlitePackage.SEQUENCE_EXP:
				sequence_SequenceExp(context, (SequenceExp) semanticObject); 
				return; 
			case OCLlitePackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case OCLlitePackage.SET_EXP:
				sequence_SetExp(context, (SetExp) semanticObject); 
				return; 
			case OCLlitePackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case OCLlitePackage.STRING_LITERAL_EXP:
				sequence_StringExp(context, (StringLiteralExp) semanticObject); 
				return; 
			case OCLlitePackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case OCLlitePackage.TUPLE_EXP:
				sequence_TupleExp(context, (TupleExp) semanticObject); 
				return; 
			case OCLlitePackage.TUPLE_PART:
				sequence_TuplePart(context, (TuplePart) semanticObject); 
				return; 
			case OCLlitePackage.URI_:
				sequence_URI_(context, (URI_) semanticObject); 
				return; 
			case OCLlitePackage.UNLIMITED_NATURAL_LITERAL_EXP:
				sequence_UnlimitedNaturalExp(context, (UnlimitedNaturalLiteralExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     OclLExpression returns AddOpCallExp
	 *     ImpliesOpExp returns AddOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     XorOpExp returns AddOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     OrOpExp returns AddOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     AndOpExp returns AddOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     EqOpExp returns AddOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns AddOpCallExp
	 *     ComparisonOpExp returns AddOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns AddOpCallExp
	 *     AdditionOpExp returns AddOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns AddOpCallExp
	 *
	 * Constraint:
	 *     (source=AdditionOpExp_AddOpCallExp_1_0 (name='+' | name='-') target=MultiOpExp)
	 */
	protected void sequence_AdditionOpExp(ISerializationContext context, AddOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllInstancesOpCall returns OperationCall
	 *
	 * Constraint:
	 *     name='allInstances'
	 */
	protected void sequence_AllInstancesOpCall(ISerializationContext context, OperationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllInstancesOpCallAccess().getNameAllInstancesKeyword_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AndOpExp returns BoolOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 */
	protected void sequence_AndOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.BOOL_OP_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.BOOL_OP_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getAndOpExpAccess().getNameAndOperatorParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAndOpExpAccess().getTargetEqOpExpParserRuleCall_1_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns BoolOpCallExp
	 *     ImpliesOpExp returns BoolOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (
	 *         (source=ImpliesOpExp_BoolOpCallExp_1_0 name=ImpliesOperator target=XorOpExp) | 
	 *         (source=XorOpExp_BoolOpCallExp_1_0 name=XorOperator target=OrOpExp) | 
	 *         (source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | 
	 *         (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 *     )
	 */
	protected void sequence_AndOpExp_ImpliesOpExp_OrOpExp_XorOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrOpExp returns BoolOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     ((source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp))
	 */
	protected void sequence_AndOpExp_OrOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorOpExp returns BoolOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (
	 *         (source=XorOpExp_BoolOpCallExp_1_0 name=XorOperator target=OrOpExp) | 
	 *         (source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | 
	 *         (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 *     )
	 */
	protected void sequence_AndOpExp_OrOpExp_XorOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns BagExp
	 *     ImpliesOpExp returns BagExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns BagExp
	 *     XorOpExp returns BagExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns BagExp
	 *     OrOpExp returns BagExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns BagExp
	 *     AndOpExp returns BagExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns BagExp
	 *     EqOpExp returns BagExp
	 *     EqOpExp.EqOpCallExp_1_0 returns BagExp
	 *     ComparisonOpExp returns BagExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns BagExp
	 *     AdditionOpExp returns BagExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns BagExp
	 *     MultiOpExp returns BagExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns BagExp
	 *     NavOpExp returns BagExp
	 *     NavOpExp.NavigationExp_1_0 returns BagExp
	 *     NavigationOpCallExp returns BagExp
	 *     PrimaryExp returns BagExp
	 *     CollectionExp returns BagExp
	 *     BagExp returns BagExp
	 *
	 * Constraint:
	 *     (parts+=OclLExpression parts+=OclLExpression)
	 */
	protected void sequence_BagExp(ISerializationContext context, BagExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     (name='BagType' elementType=OclLType)
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.BAG_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.BAG_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.BAG_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.BAG_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagTypeAccess().getNameBagTypeKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBagTypeAccess().getElementTypeOclLTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns BooleanLiteralExp
	 *     ImpliesOpExp returns BooleanLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     XorOpExp returns BooleanLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     OrOpExp returns BooleanLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     AndOpExp returns BooleanLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     EqOpExp returns BooleanLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns BooleanLiteralExp
	 *     ComparisonOpExp returns BooleanLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns BooleanLiteralExp
	 *     AdditionOpExp returns BooleanLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns BooleanLiteralExp
	 *     MultiOpExp returns BooleanLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns BooleanLiteralExp
	 *     NavOpExp returns BooleanLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns BooleanLiteralExp
	 *     NavigationOpCallExp returns BooleanLiteralExp
	 *     PrimaryExp returns BooleanLiteralExp
	 *     PrimitiveExp returns BooleanLiteralExp
	 *     BooleanExp returns BooleanLiteralExp
	 *
	 * Constraint:
	 *     (symbol='true' | symbol='false')
	 */
	protected void sequence_BooleanExp(ISerializationContext context, BooleanLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     name='Boolean'
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.BOOLEAN_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.BOOLEAN_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getNameBooleanKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns CollectionOpCallExp
	 *     ImpliesOpExp returns CollectionOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     XorOpExp returns CollectionOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     OrOpExp returns CollectionOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     AndOpExp returns CollectionOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     EqOpExp returns CollectionOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns CollectionOpCallExp
	 *     ComparisonOpExp returns CollectionOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns CollectionOpCallExp
	 *     AdditionOpExp returns CollectionOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns CollectionOpCallExp
	 *     MultiOpExp returns CollectionOpCallExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns CollectionOpCallExp
	 *     NavOpExp returns CollectionOpCallExp
	 *     NavOpExp.NavigationExp_1_0 returns CollectionOpCallExp
	 *     NavigationOpCallExp returns CollectionOpCallExp
	 *     CollectionOpCall returns CollectionOpCallExp
	 *
	 * Constraint:
	 *     (name=CollectionOpID (arguments+=OclLExpression arguments+=OclLExpression*)?)
	 */
	protected void sequence_CollectionOpCall(ISerializationContext context, CollectionOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns ComOpCallExp
	 *     ImpliesOpExp returns ComOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     XorOpExp returns ComOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     OrOpExp returns ComOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     AndOpExp returns ComOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     EqOpExp returns ComOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns ComOpCallExp
	 *     ComparisonOpExp returns ComOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns ComOpCallExp
	 *
	 * Constraint:
	 *     (source=ComparisonOpExp_ComOpCallExp_1_0 (name='>' | name='<' | name='>=' | name='<=') target=AdditionOpExp)
	 */
	protected void sequence_ComparisonOpExp(ISerializationContext context, ComOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfThenExp returns ElseIfThenExp
	 *
	 * Constraint:
	 *     (name='elseif' condition=OclLExpression then=OclLExpression)
	 */
	protected void sequence_ElseIfThenExp(ISerializationContext context, ElseIfThenExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.ELSE_IF_THEN_EXP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.ELSE_IF_THEN_EXP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.ELSE_IF_THEN_EXP__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.ELSE_IF_THEN_EXP__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getNameElseifKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getConditionOclLExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getThenOclLExpressionParserRuleCall_4_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns EnvType
	 *     EnvType returns EnvType
	 *
	 * Constraint:
	 *     name='Env'
	 */
	protected void sequence_EnvType(ISerializationContext context, EnvType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.ENV_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.ENV_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvTypeAccess().getNameEnvKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns EqOpCallExp
	 *     ImpliesOpExp returns EqOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     XorOpExp returns EqOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     OrOpExp returns EqOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     AndOpExp returns EqOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     EqOpExp returns EqOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns EqOpCallExp
	 *
	 * Constraint:
	 *     (source=EqOpExp_EqOpCallExp_1_0 (name='<>' | name='=') target=ComparisonOpExp)
	 */
	protected void sequence_EqOpExp(ISerializationContext context, EqOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns IfExp
	 *     ImpliesOpExp returns IfExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     XorOpExp returns IfExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     OrOpExp returns IfExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     AndOpExp returns IfExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     EqOpExp returns IfExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IfExp
	 *     ComparisonOpExp returns IfExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IfExp
	 *     AdditionOpExp returns IfExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IfExp
	 *     MultiOpExp returns IfExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IfExp
	 *     NavOpExp returns IfExp
	 *     NavOpExp.NavigationExp_1_0 returns IfExp
	 *     NavigationOpCallExp returns IfExp
	 *     PrimaryExp returns IfExp
	 *     IfExp returns IfExp
	 *
	 * Constraint:
	 *     (name='if' condition=OclLExpression then=OclLExpression ifThen+=ElseIfThenExp* else=OclLExpression)
	 */
	protected void sequence_IfExp(ISerializationContext context, IfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     name='Integer'
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.INTEGER_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.INTEGER_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerTypeAccess().getNameIntegerKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns InvalidLiteralExp
	 *     ImpliesOpExp returns InvalidLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     XorOpExp returns InvalidLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     OrOpExp returns InvalidLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     AndOpExp returns InvalidLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     EqOpExp returns InvalidLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns InvalidLiteralExp
	 *     ComparisonOpExp returns InvalidLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns InvalidLiteralExp
	 *     AdditionOpExp returns InvalidLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns InvalidLiteralExp
	 *     MultiOpExp returns InvalidLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns InvalidLiteralExp
	 *     NavOpExp returns InvalidLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns InvalidLiteralExp
	 *     NavigationOpCallExp returns InvalidLiteralExp
	 *     PrimaryExp returns InvalidLiteralExp
	 *     PrimitiveExp returns InvalidLiteralExp
	 *     InvalidExp returns InvalidLiteralExp
	 *
	 * Constraint:
	 *     {InvalidLiteralExp}
	 */
	protected void sequence_InvalidExp(ISerializationContext context, InvalidLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns IterateExp
	 *     ImpliesOpExp returns IterateExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     XorOpExp returns IterateExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     OrOpExp returns IterateExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     AndOpExp returns IterateExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     EqOpExp returns IterateExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IterateExp
	 *     ComparisonOpExp returns IterateExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IterateExp
	 *     AdditionOpExp returns IterateExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IterateExp
	 *     MultiOpExp returns IterateExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IterateExp
	 *     NavOpExp returns IterateExp
	 *     NavOpExp.NavigationExp_1_0 returns IterateExp
	 *     NavigationOpCallExp returns IterateExp
	 *     IterateExp returns IterateExp
	 *
	 * Constraint:
	 *     (name='iterate' iterators+=Iterator iterators+=Iterator* result=LocalVariable body=OclLExpression)
	 */
	protected void sequence_IterateExp(ISerializationContext context, IterateExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns IteratorExp
	 *     ImpliesOpExp returns IteratorExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     XorOpExp returns IteratorExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     OrOpExp returns IteratorExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     AndOpExp returns IteratorExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     EqOpExp returns IteratorExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IteratorExp
	 *     ComparisonOpExp returns IteratorExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IteratorExp
	 *     AdditionOpExp returns IteratorExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IteratorExp
	 *     MultiOpExp returns IteratorExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IteratorExp
	 *     NavOpExp returns IteratorExp
	 *     NavOpExp.NavigationExp_1_0 returns IteratorExp
	 *     NavigationOpCallExp returns IteratorExp
	 *     IteratorExp returns IteratorExp
	 *
	 * Constraint:
	 *     (name=IterativeOperationID iterators+=Iterator iterators+=Iterator* body=OclLExpression)
	 */
	protected void sequence_IteratorExp(ISerializationContext context, IteratorExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (name=ID type=OclLType?)
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns LambdaExp
	 *     ImpliesOpExp returns LambdaExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     XorOpExp returns LambdaExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     OrOpExp returns LambdaExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     AndOpExp returns LambdaExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     EqOpExp returns LambdaExp
	 *     EqOpExp.EqOpCallExp_1_0 returns LambdaExp
	 *     ComparisonOpExp returns LambdaExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns LambdaExp
	 *     AdditionOpExp returns LambdaExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns LambdaExp
	 *     MultiOpExp returns LambdaExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns LambdaExp
	 *     NavOpExp returns LambdaExp
	 *     NavOpExp.NavigationExp_1_0 returns LambdaExp
	 *     NavigationOpCallExp returns LambdaExp
	 *     PrimaryExp returns LambdaExp
	 *     LambdaExp returns LambdaExp
	 *
	 * Constraint:
	 *     (name='Lambda' expression=OclLExpression)
	 */
	protected void sequence_LambdaExp(ISerializationContext context, LambdaExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.LAMBDA_EXP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.LAMBDA_EXP__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLambdaExpAccess().getNameLambdaKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLambdaExpAccess().getExpressionOclLExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns LambdaType
	 *     LambdaType returns LambdaType
	 *
	 * Constraint:
	 *     (name='Lambda' argsTypes+=OclLType argsTypes+=OclLType* returnType=OclLType)
	 */
	protected void sequence_LambdaType(ISerializationContext context, LambdaType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LetExp returns OclLExpression
	 *
	 * Constraint:
	 *     (name='let' variable=LocalVariable in=OclLExpression)
	 */
	protected void sequence_LetExp(ISerializationContext context, OclLExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__IN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetExpAccess().getNameLetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetExpAccess().getVariableLocalVariableParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLetExpAccess().getInOclLExpressionParserRuleCall_3_0(), semanticObject.getIn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns OclLExpression
	 *
	 * Constraint:
	 *     (
	 *         (name='let' variable=LocalVariable in=OclLExpression) | 
	 *         (name=UnaryOperator target=OclLExpression) | 
	 *         (model=OclLModel name='::' elements+=ID elements+=ID* target=AllInstancesOpCall?)
	 *     )
	 */
	protected void sequence_LetExp_OclLModelElementExp_UnaryOpExp(ISerializationContext context, OclLExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID type=OclLType initExp=OclLExpression)
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__INIT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.LOCAL_VARIABLE__INIT_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableAccess().getTypeOclLTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLocalVariableAccess().getInitExpOclLExpressionParserRuleCall_4_0(), semanticObject.getInitExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MapElement returns MapElement
	 *
	 * Constraint:
	 *     (key=OclLExpression value=OclLExpression)
	 */
	protected void sequence_MapElement(ISerializationContext context, MapElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.MAP_ELEMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.MAP_ELEMENT__KEY));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.MAP_ELEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.MAP_ELEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapElementAccess().getKeyOclLExpressionParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapElementAccess().getValueOclLExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns MapExp
	 *     ImpliesOpExp returns MapExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns MapExp
	 *     XorOpExp returns MapExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns MapExp
	 *     OrOpExp returns MapExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns MapExp
	 *     AndOpExp returns MapExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns MapExp
	 *     EqOpExp returns MapExp
	 *     EqOpExp.EqOpCallExp_1_0 returns MapExp
	 *     ComparisonOpExp returns MapExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns MapExp
	 *     AdditionOpExp returns MapExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns MapExp
	 *     MultiOpExp returns MapExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns MapExp
	 *     NavOpExp returns MapExp
	 *     NavOpExp.NavigationExp_1_0 returns MapExp
	 *     NavigationOpCallExp returns MapExp
	 *     PrimaryExp returns MapExp
	 *     MapExp returns MapExp
	 *
	 * Constraint:
	 *     (name='Map' mapElements+=MapElement mapElements+=MapElement*)
	 */
	protected void sequence_MapExp(ISerializationContext context, MapExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (name='Map' keyType=OclLType valueType=OclLType)
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.MAP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.MAP_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.MAP_TYPE__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.MAP_TYPE__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.MAP_TYPE__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.MAP_TYPE__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getNameMapKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapTypeAccess().getKeyTypeOclLTypeParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMapTypeAccess().getValueTypeOclLTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID source=OclLModel input=OclLModel (imports+=Import imports+=Import*)? (elements+=ModuleElement elements+=ModuleElement*)?)
	 */
	protected void sequence_Module(ISerializationContext context, Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns MulOpCallExp
	 *     ImpliesOpExp returns MulOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     XorOpExp returns MulOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     OrOpExp returns MulOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     AndOpExp returns MulOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     EqOpExp returns MulOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns MulOpCallExp
	 *     ComparisonOpExp returns MulOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns MulOpCallExp
	 *     AdditionOpExp returns MulOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns MulOpCallExp
	 *     MultiOpExp returns MulOpCallExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns MulOpCallExp
	 *
	 * Constraint:
	 *     (source=MultiOpExp_MulOpCallExp_1_0 (name='*' | name='/') target=NavOpExp)
	 */
	protected void sequence_MultiOpExp(ISerializationContext context, MulOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns NavigationExp
	 *     ImpliesOpExp returns NavigationExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     XorOpExp returns NavigationExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     OrOpExp returns NavigationExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     AndOpExp returns NavigationExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     EqOpExp returns NavigationExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NavigationExp
	 *     ComparisonOpExp returns NavigationExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NavigationExp
	 *     AdditionOpExp returns NavigationExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NavigationExp
	 *     MultiOpExp returns NavigationExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NavigationExp
	 *     NavOpExp returns NavigationExp
	 *     NavOpExp.NavigationExp_1_0 returns NavigationExp
	 *
	 * Constraint:
	 *     (source=NavOpExp_NavigationExp_1_0 name=NavigationOperator target=NavigationOpCallExp)
	 */
	protected void sequence_NavOpExp(ISerializationContext context, NavigationExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.NAVIGATION_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.NAVIGATION_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getNavOpExpAccess().getNameNavigationOperatorParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNavOpExpAccess().getTargetNavigationOpCallExpParserRuleCall_1_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns NavigationOrAttributeCall
	 *     ImpliesOpExp returns NavigationOrAttributeCall
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     XorOpExp returns NavigationOrAttributeCall
	 *     XorOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     OrOpExp returns NavigationOrAttributeCall
	 *     OrOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     AndOpExp returns NavigationOrAttributeCall
	 *     AndOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     EqOpExp returns NavigationOrAttributeCall
	 *     EqOpExp.EqOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     ComparisonOpExp returns NavigationOrAttributeCall
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     AdditionOpExp returns NavigationOrAttributeCall
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     MultiOpExp returns NavigationOrAttributeCall
	 *     MultiOpExp.MulOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     NavOpExp returns NavigationOrAttributeCall
	 *     NavOpExp.NavigationExp_1_0 returns NavigationOrAttributeCall
	 *     NavigationOpCallExp returns NavigationOrAttributeCall
	 *     NavigationOrAttributeCall returns NavigationOrAttributeCall
	 *
	 * Constraint:
	 *     feature=ID
	 */
	protected void sequence_NavigationOrAttributeCall(ISerializationContext context, NavigationOrAttributeCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.NAVIGATION_OR_ATTRIBUTE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.NAVIGATION_OR_ATTRIBUTE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationOrAttributeCallAccess().getFeatureIDTerminalRuleCall_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns NestedExp
	 *     ImpliesOpExp returns NestedExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     XorOpExp returns NestedExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     OrOpExp returns NestedExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     AndOpExp returns NestedExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     EqOpExp returns NestedExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NestedExp
	 *     ComparisonOpExp returns NestedExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NestedExp
	 *     AdditionOpExp returns NestedExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NestedExp
	 *     MultiOpExp returns NestedExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NestedExp
	 *     NavOpExp returns NestedExp
	 *     NavOpExp.NavigationExp_1_0 returns NestedExp
	 *     NavigationOpCallExp returns NestedExp
	 *     PrimaryExp returns NestedExp
	 *     NestedExp returns NestedExp
	 *
	 * Constraint:
	 *     exp=OclLExpression
	 */
	protected void sequence_NestedExp(ISerializationContext context, NestedExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.NESTED_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.NESTED_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedExpAccess().getExpOclLExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns NullLiteralExp
	 *     ImpliesOpExp returns NullLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     XorOpExp returns NullLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     OrOpExp returns NullLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     AndOpExp returns NullLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     EqOpExp returns NullLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NullLiteralExp
	 *     ComparisonOpExp returns NullLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NullLiteralExp
	 *     AdditionOpExp returns NullLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NullLiteralExp
	 *     MultiOpExp returns NullLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NullLiteralExp
	 *     NavOpExp returns NullLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns NullLiteralExp
	 *     NavigationOpCallExp returns NullLiteralExp
	 *     PrimaryExp returns NullLiteralExp
	 *     PrimitiveExp returns NullLiteralExp
	 *     NullExp returns NullLiteralExp
	 *
	 * Constraint:
	 *     {NullLiteralExp}
	 */
	protected void sequence_NullExp(ISerializationContext context, NullLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns NumberLiteralExp
	 *     ImpliesOpExp returns NumberLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     XorOpExp returns NumberLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     OrOpExp returns NumberLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     AndOpExp returns NumberLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     EqOpExp returns NumberLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NumberLiteralExp
	 *     ComparisonOpExp returns NumberLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NumberLiteralExp
	 *     AdditionOpExp returns NumberLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NumberLiteralExp
	 *     MultiOpExp returns NumberLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NumberLiteralExp
	 *     NavOpExp returns NumberLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns NumberLiteralExp
	 *     NavigationOpCallExp returns NumberLiteralExp
	 *     PrimaryExp returns NumberLiteralExp
	 *     PrimitiveExp returns NumberLiteralExp
	 *     NumberExp returns NumberLiteralExp
	 *
	 * Constraint:
	 *     symbol=INT
	 */
	protected void sequence_NumberExp(ISerializationContext context, NumberLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.NUMBER_LITERAL_EXP__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.NUMBER_LITERAL_EXP__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberExpAccess().getSymbolINTTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns OclLAnyType
	 *     OclLAnyType returns OclLAnyType
	 *
	 * Constraint:
	 *     name='OclLAny'
	 */
	protected void sequence_OclLAnyType(ISerializationContext context, OclLAnyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LANY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LANY_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclLAnyTypeAccess().getNameOclLAnyKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImpliesOpExp returns OclLExpression
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns OclLExpression
	 *     XorOpExp returns OclLExpression
	 *     XorOpExp.BoolOpCallExp_1_0 returns OclLExpression
	 *     OrOpExp returns OclLExpression
	 *     OrOpExp.BoolOpCallExp_1_0 returns OclLExpression
	 *     AndOpExp returns OclLExpression
	 *     AndOpExp.BoolOpCallExp_1_0 returns OclLExpression
	 *     EqOpExp returns OclLExpression
	 *     EqOpExp.EqOpCallExp_1_0 returns OclLExpression
	 *     ComparisonOpExp returns OclLExpression
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns OclLExpression
	 *     AdditionOpExp returns OclLExpression
	 *     AdditionOpExp.AddOpCallExp_1_0 returns OclLExpression
	 *     MultiOpExp returns OclLExpression
	 *     MultiOpExp.MulOpCallExp_1_0 returns OclLExpression
	 *     NavOpExp returns OclLExpression
	 *     NavOpExp.NavigationExp_1_0 returns OclLExpression
	 *     NavigationOpCallExp returns OclLExpression
	 *     OclLModelElementExp returns OclLExpression
	 *     PrimaryExp returns OclLExpression
	 *
	 * Constraint:
	 *     (model=OclLModel name='::' elements+=ID elements+=ID* target=AllInstancesOpCall?)
	 */
	protected void sequence_OclLModelElementExp(ISerializationContext context, OclLExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns OclLModelElementExp
	 *     OclLModelElement returns OclLModelElementExp
	 *
	 * Constraint:
	 *     (model=OclLModel name=ID)
	 */
	protected void sequence_OclLModelElement(ISerializationContext context, OclLModelElementExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LMODEL_ELEMENT_EXP__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LMODEL_ELEMENT_EXP__MODEL));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LMODEL_ELEMENT_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LMODEL_ELEMENT_EXP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclLModelElementAccess().getModelOclLModelParserRuleCall_0_0(), semanticObject.getModel());
		feeder.accept(grammarAccess.getOclLModelElementAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLModel returns OclLModel
	 *
	 * Constraint:
	 *     (name=ID uri=URI_?)
	 */
	protected void sequence_OclLModel(ISerializationContext context, OclLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns OperationCall
	 *     ImpliesOpExp returns OperationCall
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     XorOpExp returns OperationCall
	 *     XorOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     OrOpExp returns OperationCall
	 *     OrOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     AndOpExp returns OperationCall
	 *     AndOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     EqOpExp returns OperationCall
	 *     EqOpExp.EqOpCallExp_1_0 returns OperationCall
	 *     ComparisonOpExp returns OperationCall
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns OperationCall
	 *     AdditionOpExp returns OperationCall
	 *     AdditionOpExp.AddOpCallExp_1_0 returns OperationCall
	 *     MultiOpExp returns OperationCall
	 *     MultiOpExp.MulOpCallExp_1_0 returns OperationCall
	 *     NavOpExp returns OperationCall
	 *     NavOpExp.NavigationExp_1_0 returns OperationCall
	 *     NavigationOpCallExp returns OperationCall
	 *     OperationCall returns OperationCall
	 *
	 * Constraint:
	 *     (name=ID (arguments+=OclLExpression arguments+=OclLExpression*)?)
	 */
	protected void sequence_OperationCall(ISerializationContext context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns OrderedSetExp
	 *     ImpliesOpExp returns OrderedSetExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns OrderedSetExp
	 *     XorOpExp returns OrderedSetExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns OrderedSetExp
	 *     OrOpExp returns OrderedSetExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns OrderedSetExp
	 *     AndOpExp returns OrderedSetExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns OrderedSetExp
	 *     EqOpExp returns OrderedSetExp
	 *     EqOpExp.EqOpCallExp_1_0 returns OrderedSetExp
	 *     ComparisonOpExp returns OrderedSetExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns OrderedSetExp
	 *     AdditionOpExp returns OrderedSetExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns OrderedSetExp
	 *     MultiOpExp returns OrderedSetExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns OrderedSetExp
	 *     NavOpExp returns OrderedSetExp
	 *     NavOpExp.NavigationExp_1_0 returns OrderedSetExp
	 *     NavigationOpCallExp returns OrderedSetExp
	 *     PrimaryExp returns OrderedSetExp
	 *     CollectionExp returns OrderedSetExp
	 *     OrderedSetExp returns OrderedSetExp
	 *
	 * Constraint:
	 *     (name='OrderedSet' parts+=OclLExpression parts+=OclLExpression)
	 */
	protected void sequence_OrderedSetExp(ISerializationContext context, OrderedSetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns OrderedSetType
	 *     OrderedSetType returns OrderedSetType
	 *
	 * Constraint:
	 *     (name='OrderedSet' elementType=OclLType)
	 */
	protected void sequence_OrderedSetType(ISerializationContext context, OrderedSetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.ORDERED_SET_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.ORDERED_SET_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.ORDERED_SET_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.ORDERED_SET_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getNameOrderedSetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getElementTypeOclLTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns Query
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (name=ID body=OclLExpression)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.QUERY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.QUERY__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.QUERY__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.QUERY__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQueryAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getQueryAccess().getBodyOclLExpressionParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     name='Real'
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.REAL_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.REAL_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealTypeAccess().getNameRealKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns SelfExp
	 *     ImpliesOpExp returns SelfExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     XorOpExp returns SelfExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     OrOpExp returns SelfExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     AndOpExp returns SelfExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     EqOpExp returns SelfExp
	 *     EqOpExp.EqOpCallExp_1_0 returns SelfExp
	 *     ComparisonOpExp returns SelfExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns SelfExp
	 *     AdditionOpExp returns SelfExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns SelfExp
	 *     MultiOpExp returns SelfExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns SelfExp
	 *     NavOpExp returns SelfExp
	 *     NavOpExp.NavigationExp_1_0 returns SelfExp
	 *     NavigationOpCallExp returns SelfExp
	 *     PrimaryExp returns SelfExp
	 *     SeflExp returns SelfExp
	 *
	 * Constraint:
	 *     name='self'
	 */
	protected void sequence_SeflExp(ISerializationContext context, SelfExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeflExpAccess().getNameSelfKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns SequenceExp
	 *     ImpliesOpExp returns SequenceExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns SequenceExp
	 *     XorOpExp returns SequenceExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns SequenceExp
	 *     OrOpExp returns SequenceExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns SequenceExp
	 *     AndOpExp returns SequenceExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns SequenceExp
	 *     EqOpExp returns SequenceExp
	 *     EqOpExp.EqOpCallExp_1_0 returns SequenceExp
	 *     ComparisonOpExp returns SequenceExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns SequenceExp
	 *     AdditionOpExp returns SequenceExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns SequenceExp
	 *     MultiOpExp returns SequenceExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns SequenceExp
	 *     NavOpExp returns SequenceExp
	 *     NavOpExp.NavigationExp_1_0 returns SequenceExp
	 *     NavigationOpCallExp returns SequenceExp
	 *     PrimaryExp returns SequenceExp
	 *     CollectionExp returns SequenceExp
	 *     SequenceExp returns SequenceExp
	 *
	 * Constraint:
	 *     (name='Sequence' parts+=OclLExpression parts+=OclLExpression)
	 */
	protected void sequence_SequenceExp(ISerializationContext context, SequenceExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns SequenceType
	 *     SequenceType returns SequenceType
	 *
	 * Constraint:
	 *     (name='Sequence' elementType=OclLType)
	 */
	protected void sequence_SequenceType(ISerializationContext context, SequenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.SEQUENCE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.SEQUENCE_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.SEQUENCE_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.SEQUENCE_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceTypeAccess().getNameSequenceKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSequenceTypeAccess().getElementTypeOclLTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns SetExp
	 *     ImpliesOpExp returns SetExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns SetExp
	 *     XorOpExp returns SetExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns SetExp
	 *     OrOpExp returns SetExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns SetExp
	 *     AndOpExp returns SetExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns SetExp
	 *     EqOpExp returns SetExp
	 *     EqOpExp.EqOpCallExp_1_0 returns SetExp
	 *     ComparisonOpExp returns SetExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns SetExp
	 *     AdditionOpExp returns SetExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns SetExp
	 *     MultiOpExp returns SetExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns SetExp
	 *     NavOpExp returns SetExp
	 *     NavOpExp.NavigationExp_1_0 returns SetExp
	 *     NavigationOpCallExp returns SetExp
	 *     PrimaryExp returns SetExp
	 *     CollectionExp returns SetExp
	 *     SetExp returns SetExp
	 *
	 * Constraint:
	 *     (name='Set' parts+=OclLExpression parts+=OclLExpression)
	 */
	protected void sequence_SetExp(ISerializationContext context, SetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     (name='Set' elementType=OclLType)
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.SET_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.SET_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.SET_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.SET_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeAccess().getNameSetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSetTypeAccess().getElementTypeOclLTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns StringLiteralExp
	 *     ImpliesOpExp returns StringLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     XorOpExp returns StringLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     OrOpExp returns StringLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     AndOpExp returns StringLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     EqOpExp returns StringLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns StringLiteralExp
	 *     ComparisonOpExp returns StringLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns StringLiteralExp
	 *     AdditionOpExp returns StringLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns StringLiteralExp
	 *     MultiOpExp returns StringLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns StringLiteralExp
	 *     NavOpExp returns StringLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns StringLiteralExp
	 *     NavigationOpCallExp returns StringLiteralExp
	 *     PrimaryExp returns StringLiteralExp
	 *     PrimitiveExp returns StringLiteralExp
	 *     StringExp returns StringLiteralExp
	 *
	 * Constraint:
	 *     segments+=STRING+
	 */
	protected void sequence_StringExp(ISerializationContext context, StringLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclLType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     name='String'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.STRING_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.STRING_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getNameStringKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns TupleExp
	 *     ImpliesOpExp returns TupleExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     XorOpExp returns TupleExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     OrOpExp returns TupleExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     AndOpExp returns TupleExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     EqOpExp returns TupleExp
	 *     EqOpExp.EqOpCallExp_1_0 returns TupleExp
	 *     ComparisonOpExp returns TupleExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns TupleExp
	 *     AdditionOpExp returns TupleExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns TupleExp
	 *     MultiOpExp returns TupleExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns TupleExp
	 *     NavOpExp returns TupleExp
	 *     NavOpExp.NavigationExp_1_0 returns TupleExp
	 *     NavigationOpCallExp returns TupleExp
	 *     PrimaryExp returns TupleExp
	 *     TupleExp returns TupleExp
	 *
	 * Constraint:
	 *     (name='Tuple' parts+=TuplePart parts+=TuplePart*)
	 */
	protected void sequence_TupleExp(ISerializationContext context, TupleExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TuplePart returns TuplePart
	 *
	 * Constraint:
	 *     (name=STRING type=OclLType? init=OclLExpression)
	 */
	protected void sequence_TuplePart(ISerializationContext context, TuplePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URI_ returns URI_
	 *
	 * Constraint:
	 *     (scheme=SCHEME authority=AUTHORITY fragment_=FRAGMENT)
	 */
	protected void sequence_URI_(ISerializationContext context, URI_ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.URI___SCHEME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.URI___SCHEME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.URI___AUTHORITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.URI___AUTHORITY));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.URI___FRAGMENT_) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.URI___FRAGMENT_));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getURI_Access().getSchemeSCHEMETerminalRuleCall_1_0(), semanticObject.getScheme());
		feeder.accept(grammarAccess.getURI_Access().getAuthorityAUTHORITYParserRuleCall_3_0(), semanticObject.getAuthority());
		feeder.accept(grammarAccess.getURI_Access().getFragment_FRAGMENTParserRuleCall_5_0(), semanticObject.getFragment_());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnaryOpExp returns OclLExpression
	 *
	 * Constraint:
	 *     (name=UnaryOperator target=OclLExpression)
	 */
	protected void sequence_UnaryOpExp(ISerializationContext context, OclLExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OCLlitePackage.Literals.OCL_LEXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOpExpAccess().getNameUnaryOperatorParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUnaryOpExpAccess().getTargetOclLExpressionParserRuleCall_1_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclLExpression returns UnlimitedNaturalLiteralExp
	 *     ImpliesOpExp returns UnlimitedNaturalLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     XorOpExp returns UnlimitedNaturalLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     OrOpExp returns UnlimitedNaturalLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     AndOpExp returns UnlimitedNaturalLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     EqOpExp returns UnlimitedNaturalLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     ComparisonOpExp returns UnlimitedNaturalLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     AdditionOpExp returns UnlimitedNaturalLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     MultiOpExp returns UnlimitedNaturalLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     NavOpExp returns UnlimitedNaturalLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     NavigationOpCallExp returns UnlimitedNaturalLiteralExp
	 *     PrimaryExp returns UnlimitedNaturalLiteralExp
	 *     PrimitiveExp returns UnlimitedNaturalLiteralExp
	 *     UnlimitedNaturalExp returns UnlimitedNaturalLiteralExp
	 *
	 * Constraint:
	 *     {UnlimitedNaturalLiteralExp}
	 */
	protected void sequence_UnlimitedNaturalExp(ISerializationContext context, UnlimitedNaturalLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
